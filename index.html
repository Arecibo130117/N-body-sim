<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>N-Body Sim: Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050508; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        #instructions {
            position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.6);
            pointer-events: none; user-select: none; text-shadow: 1px 1px 2px black;
        }
        b { color: #ff9d00; }
        h2 { margin-bottom: 5px; color: #fff; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="instructions">
        <h2>N-Body Fracture & Fire Sim (Optimized)</h2>
        <p>Left Click + Drag: <b>Spawn Body</b></p>
        <p>Right Click: <b>Rotate Camera</b></p>
        <p>Wheel: <b>Zoom</b></p>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'three/addons/libs/lil-gui.module.min.js';

        // ==========================================
        // 1. CONFIGURATION
        // ==========================================
        const CONFIG = {
            G: 0.5,                
            softening: 0.5,        
            dt: 0.016,             
            subSteps: 2,           
            maxBodies: 500,        
            trailLength: 80,       // [Optimized] 성능과 시각적 효과의 타협점 (100 -> 80)
            
            // Fracture Props
            fractureThreshold: 15, 
            minFragmentMass: 0.2,  
            
            // Thermal Props
            heatDecay: 0.995,      
            heatToGlow: 2.0,       
            
            materials: {
                rock: { density: 1.0, color: 0x888888, emit: 0x331100, roughness: 0.9 },
                metal: { density: 3.0, color: 0xaaaaaa, emit: 0x001133, roughness: 0.4 },
                ice: { density: 0.5, color: 0xaaccff, emit: 0x0044aa, roughness: 0.1 }
            }
        };

        // Pre-allocate vectors to avoid GC overhead
        const _v1 = new THREE.Vector3();
        const _v2 = new THREE.Vector3();
        const _v3 = new THREE.Vector3();
        const _camPos = new THREE.Vector3();

        // ==========================================
        // 2. PHYSICS ENGINE
        // ==========================================
        
        class Body {
            constructor(mass, pos, vel, type = 'rock', temp = 0) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.mass = mass;
                this.invMass = mass > 0 ? 1 / mass : 0;
                
                this.pos = pos.clone();
                this.prevPos = pos.clone(); 
                this.vel = vel.clone();
                this.acc = new THREE.Vector3(0, 0, 0);
                
                this.type = type;
                this.matProps = CONFIG.materials[type];
                this.radius = Math.pow((3 * mass) / (4 * Math.PI * this.matProps.density), 1/3);
                
                this.temperature = temp;
                
                // Ring buffer for history to avoid array shifting overhead
                this.historySize = CONFIG.trailLength;
                this.historyX = new Float32Array(this.historySize);
                this.historyY = new Float32Array(this.historySize);
                this.historyZ = new Float32Array(this.historySize);
                this.headIdx = 0;
                this.historyCount = 0;
            }

            pushHistory() {
                this.headIdx = (this.headIdx + 1) % this.historySize;
                this.historyX[this.headIdx] = this.pos.x;
                this.historyY[this.headIdx] = this.pos.y;
                this.historyZ[this.headIdx] = this.pos.z;
                if (this.historyCount < this.historySize) this.historyCount++;
            }

            getHistoryPos(offset, targetVec) {
                // offset 0 is current head, 1 is previous...
                let idx = this.headIdx - offset;
                if (idx < 0) idx += this.historySize;
                targetVec.set(this.historyX[idx], this.historyY[idx], this.historyZ[idx]);
            }

            updateThermal() {
                this.temperature *= CONFIG.heatDecay;
                if(this.temperature < 0.1) this.temperature = 0;
            }
        }

        class PhysicsSystem {
            constructor() {
                this.bodies = [];
            }

            addBody(body) {
                if (this.bodies.length >= CONFIG.maxBodies) {
                    const removed = this.bodies.shift();
                    // Mark for cleanup in visual system if needed
                }
                this.bodies.push(body);
                return body;
            }

            integrate(dt) {
                const halfDt = 0.5 * dt;

                // 1. First half-step velocity update
                for (let i = 0; i < this.bodies.length; i++) {
                    const b = this.bodies[i];
                    b.vel.x += b.acc.x * halfDt;
                    b.vel.y += b.acc.y * halfDt;
                    b.vel.z += b.acc.z * halfDt;
                    
                    b.pos.x += b.vel.x * dt;
                    b.pos.y += b.vel.y * dt;
                    b.pos.z += b.vel.z * dt;
                }

                this.computeGravity();
                this.resolveCollisions(dt);

                // 2. Second half-step velocity update & Thermal
                for (let i = 0; i < this.bodies.length; i++) {
                    const b = this.bodies[i];
                    b.vel.x += b.acc.x * halfDt;
                    b.vel.y += b.acc.y * halfDt;
                    b.vel.z += b.acc.z * halfDt;
                    
                    b.updateThermal();
                }
            }

            computeGravity() {
                const N = this.bodies.length;
                // Reset accelerations
                for (let i = 0; i < N; i++) {
                    const b = this.bodies[i];
                    b.acc.x = 0; b.acc.y = 0; b.acc.z = 0;
                }

                const G = CONFIG.G;
                const epsSq = CONFIG.softening * CONFIG.softening;

                // N^2 Gravity Loop (Optimized Math)
                for (let i = 0; i < N; i++) {
                    const A = this.bodies[i];
                    for (let j = i + 1; j < N; j++) {
                        const B = this.bodies[j];

                        const dx = B.pos.x - A.pos.x;
                        const dy = B.pos.y - A.pos.y;
                        const dz = B.pos.z - A.pos.z;
                        
                        const distSq = dx*dx + dy*dy + dz*dz;
                        const f = G / Math.pow(distSq + epsSq, 1.5);
                        
                        const fx = f * dx;
                        const fy = f * dy;
                        const fz = f * dz;

                        A.acc.x += fx * B.mass;
                        A.acc.y += fy * B.mass;
                        A.acc.z += fz * B.mass;

                        B.acc.x -= fx * A.mass;
                        B.acc.y -= fy * A.mass;
                        B.acc.z -= fz * A.mass;
                    }
                }
            }

            resolveCollisions(dt) {
                const newBodies = [];
                const removedIndices = new Set();
                const N = this.bodies.length;

                for (let i = 0; i < N; i++) {
                    if (removedIndices.has(i)) continue;
                    for (let j = i + 1; j < N; j++) {
                        if (removedIndices.has(j)) continue;

                        const A = this.bodies[i];
                        const B = this.bodies[j];
                        
                        const dx = B.pos.x - A.pos.x;
                        const dy = B.pos.y - A.pos.y;
                        const dz = B.pos.z - A.pos.z;
                        const distSq = dx*dx + dy*dy + dz*dz;
                        const minDist = A.radius + B.radius;

                        if (distSq < minDist * minDist) {
                            const dist = Math.sqrt(distSq);
                            const overlap = minDist - dist;
                            
                            // Normal vector (A to B)
                            const nx = dx / dist;
                            const ny = dy / dist;
                            const nz = dz / dist;

                            // Relative Velocity
                            const rvx = B.vel.x - A.vel.x;
                            const rvy = B.vel.y - A.vel.y;
                            const rvz = B.vel.z - A.vel.z;
                            
                            const velAlongNormal = rvx*nx + rvy*ny + rvz*nz;

                            if (velAlongNormal < 0) {
                                const restitution = 0.5;
                                const jImpulse = -(1 + restitution) * velAlongNormal / (A.invMass + B.invMass);
                                
                                const mu = (A.mass * B.mass) / (A.mass + B.mass);
                                const impactEnergy = 0.5 * mu * velAlongNormal * velAlongNormal;
                                const dissipatedEnergy = impactEnergy * (1 - restitution);
                                
                                A.temperature += (dissipatedEnergy * (B.mass / (A.mass + B.mass)) / A.mass) * 0.5;
                                B.temperature += (dissipatedEnergy * (A.mass / (A.mass + B.mass)) / B.mass) * 0.5;

                                const Q = impactEnergy / (A.mass + B.mass);
                                const isFracture = Q > CONFIG.fractureThreshold;

                                // Position Correction
                                const percent = 0.8;
                                const slop = 0.01;
                                const correctionMag = Math.max(overlap - slop, 0) / (A.invMass + B.invMass) * percent;
                                const cx = nx * correctionMag;
                                const cy = ny * correctionMag;
                                const cz = nz * correctionMag;

                                A.pos.x -= cx * A.invMass;
                                A.pos.y -= cy * A.invMass;
                                A.pos.z -= cz * A.invMass;
                                B.pos.x += cx * B.invMass;
                                B.pos.y += cy * B.invMass;
                                B.pos.z += cz * B.invMass;

                                if (isFracture && (A.mass > CONFIG.minFragmentMass || B.mass > CONFIG.minFragmentMass)) {
                                    this.fractureBodies(A, B, impactEnergy, newBodies);
                                    removedIndices.add(i);
                                    removedIndices.add(j);
                                    visuals.triggerFlash(new THREE.Vector3((A.pos.x+B.pos.x)*0.5, (A.pos.y+B.pos.y)*0.5, (A.pos.z+B.pos.z)*0.5), impactEnergy);
                                } else {
                                    const ix = nx * jImpulse;
                                    const iy = ny * jImpulse;
                                    const iz = nz * jImpulse;
                                    
                                    A.vel.x -= ix * A.invMass;
                                    A.vel.y -= iy * A.invMass;
                                    A.vel.z -= iz * A.invMass;
                                    B.vel.x += ix * B.invMass;
                                    B.vel.y += iy * B.invMass;
                                    B.vel.z += iz * B.invMass;

                                    // Friction (Tangent)
                                    // re-calc relVel
                                    const rvx2 = B.vel.x - A.vel.x;
                                    const rvy2 = B.vel.y - A.vel.y;
                                    const rvz2 = B.vel.z - A.vel.z;
                                    const vDotN = rvx2*nx + rvy2*ny + rvz2*nz;
                                    
                                    const tx = rvx2 - nx * vDotN;
                                    const ty = rvy2 - ny * vDotN;
                                    const tz = rvz2 - nz * vDotN;
                                    const tLen = Math.sqrt(tx*tx + ty*ty + tz*tz);
                                    
                                    if(tLen > 0.001) {
                                        const jt = -vDotN * 0.1 / (A.invMass + B.invMass);
                                        const fX = (tx/tLen) * jt;
                                        const fY = (ty/tLen) * jt;
                                        const fZ = (tz/tLen) * jt;
                                        
                                        A.vel.x -= fX * A.invMass;
                                        A.vel.y -= fY * A.invMass;
                                        A.vel.z -= fZ * A.invMass;
                                        B.vel.x += fX * B.invMass;
                                        B.vel.y += fY * B.invMass;
                                        B.vel.z += fZ * B.invMass;
                                    }
                                }
                            }
                        }
                    }
                }

                if (removedIndices.size > 0) {
                    this.bodies = this.bodies.filter((_, idx) => !removedIndices.has(idx));
                    visuals.garbageCollect(this.bodies);
                }
                
                for (const nb of newBodies) {
                    this.addBody(nb);
                }
            }

            fractureBodies(A, B, energy, newBodiesList) {
                const totalMass = A.mass + B.mass;
                const cmX = (A.pos.x*A.mass + B.pos.x*B.mass) / totalMass;
                const cmY = (A.pos.y*A.mass + B.pos.y*B.mass) / totalMass;
                const cmZ = (A.pos.z*A.mass + B.pos.z*B.mass) / totalMass;
                
                const mvX = A.vel.x*A.mass + B.vel.x*B.mass;
                const mvY = A.vel.y*A.mass + B.vel.y*B.mass;
                const mvZ = A.vel.z*A.mass + B.vel.z*B.mass;

                const baseVx = mvX / totalMass;
                const baseVy = mvY / totalMass;
                const baseVz = mvZ / totalMass;

                const severity = Math.min(energy / CONFIG.fractureThreshold, 5.0); 
                const numFragments = Math.floor(3 + Math.random() * 3 * severity);
                let remainingMass = totalMass;
                
                for (let k = 0; k < numFragments; k++) {
                    if (remainingMass < CONFIG.minFragmentMass) break;
                    
                    let fragMass = remainingMass * (0.3 + Math.random() * 0.4);
                    if (k === numFragments - 1) fragMass = remainingMass;
                    
                    if (fragMass < CONFIG.minFragmentMass) continue;
                    remainingMass -= fragMass;

                    // Random direction
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const rx = Math.sin(phi) * Math.cos(theta);
                    const ry = Math.sin(phi) * Math.sin(theta);
                    const rz = Math.cos(phi);

                    const rSum = (A.radius + B.radius) * 0.5 * Math.random();
                    const fragPos = new THREE.Vector3(cmX + rx*rSum, cmY + ry*rSum, cmZ + rz*rSum);
                    
                    const ejectSpeed = Math.sqrt(energy / totalMass) * (0.5 + Math.random());
                    const fragVel = new THREE.Vector3(baseVx + rx*ejectSpeed, baseVy + ry*ejectSpeed, baseVz + rz*ejectSpeed);
                    
                    const fragTemp = Math.max(A.temperature, B.temperature) + (energy / totalMass) * 0.1;
                    const type = A.mass > B.mass ? A.type : B.type;
                    
                    const frag = new Body(fragMass, fragPos, fragVel, type, fragTemp);
                    
                    newBodiesList.push(frag);
                    visuals.spawnExplosion(fragPos, fragTemp);
                }
            }
        }

        // ==========================================
        // 3. VISUALS & RENDERING (OPTIMIZED)
        // ==========================================

        class VisualSystem {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.meshMap = new Map();
                this.trailMap = new Map();
                
                this.geoLow = new THREE.IcosahedronGeometry(1, 0);
                this.geoHigh = new THREE.IcosahedronGeometry(1, 1);
                
                // Particle System (Fire & Explosions)
                this.particles = [];
                const pGeo = new THREE.BufferGeometry();
                const pMat = new THREE.PointsMaterial({ 
                    color: 0xff5500,
                    size: 0.8, 
                    blending: THREE.AdditiveBlending, 
                    transparent: true, 
                    opacity: 0.6,
                    depthWrite: false 
                });
                this.particleSystem = new THREE.Points(pGeo, pMat);
                this.particleSystem.frustumCulled = false;
                scene.add(this.particleSystem);
                
                this.maxParticles = 5000;
                this.pPositions = new Float32Array(this.maxParticles * 3);
                pGeo.setAttribute('position', new THREE.BufferAttribute(this.pPositions, 3));
            }

            update(bodies, dt) {
                const currentIds = new Set();
                _camPos.copy(this.camera.position); // Cache camera pos once per frame
                
                for(let i=0; i<bodies.length; i++) {
                    const body = bodies[i];
                    currentIds.add(body.id);
                    let mesh = this.meshMap.get(body.id);

                    // 1. Create Body Mesh if needed
                    if (!mesh) {
                        const matProps = body.matProps;
                        const mat = new THREE.MeshStandardMaterial({
                            color: matProps.color,
                            roughness: matProps.roughness,
                            emissive: 0x000000,
                            flatShading: true
                        });
                        
                        const geo = body.mass > 5 ? this.geoHigh : this.geoLow;
                        mesh = new THREE.Mesh(geo, mat);
                        this.scene.add(mesh);
                        this.meshMap.set(body.id, mesh);

                        // Ribbon Trail Setup
                        const trailLen = CONFIG.trailLength;
                        const trailGeo = new THREE.BufferGeometry();
                        const positions = new Float32Array(trailLen * 2 * 3); 
                        const indices = [];
                        for (let j = 0; j < trailLen - 1; j++) {
                            const v = j * 2;
                            indices.push(v, v+1, v+2);
                            indices.push(v+1, v+3, v+2);
                        }
                        trailGeo.setIndex(indices);
                        trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        // Mark as dynamic for optimization
                        trailGeo.attributes.position.usage = THREE.DynamicDrawUsage; 

                        const trailMat = new THREE.MeshBasicMaterial({ 
                            color: matProps.color, 
                            transparent: true, 
                            opacity: 0.3,
                            blending: THREE.AdditiveBlending,
                            side: THREE.DoubleSide,
                            depthWrite: false
                        });
                        
                        const trailMesh = new THREE.Mesh(trailGeo, trailMat);
                        trailMesh.frustumCulled = false;
                        this.scene.add(trailMesh);
                        
                        // Fill initial history
                        for(let k=0; k<trailLen; k++) body.pushHistory();

                        this.trailMap.set(body.id, { mesh: trailMesh });
                    }

                    // 2. Update Mesh
                    mesh.position.set(body.pos.x, body.pos.y, body.pos.z);
                    mesh.scale.setScalar(body.radius);
                    mesh.rotation.x += body.vel.z * 0.1 * dt;
                    mesh.rotation.y += body.vel.x * 0.1 * dt;

                    // 3. Thermal
                    if (body.temperature > 50) {
                        const intensity = Math.min(body.temperature / 1000, 1.0);
                        mesh.material.emissive.setRGB(1.0, Math.max(0, 1.0 - intensity * 0.5), Math.max(0, 1.0 - intensity));
                        mesh.material.emissiveIntensity = intensity * CONFIG.heatToGlow;

                        if (Math.random() < 0.1) this.spawnTrail(body);
                    } else {
                        mesh.material.emissive.setHex(0x000000);
                    }

                    // 4. Optimized Ribbon Update
                    const trailData = this.trailMap.get(body.id);
                    body.pushHistory(); // Update ring buffer

                    const posAttr = trailData.mesh.geometry.attributes.position;
                    const posArr = posAttr.array;
                    
                    const count = Math.min(body.historyCount, CONFIG.trailLength);
                    const halfRadius = body.radius * 0.8;

                    for (let k = 0; k < count; k++) {
                        body.getHistoryPos(k, _v1); // Current point (Head is k=0)

                        // Calculate width (Tapering)
                        const widthRatio = 1.0 - (k / (CONFIG.trailLength - 1));
                        const currentWidth = halfRadius * Math.max(0, widthRatio);
                        
                        // Direction Vector
                        if (k < count - 1) {
                            body.getHistoryPos(k+1, _v2); // Next point
                            _v2.subVectors(_v1, _v2); // dir = curr - next
                        } else {
                            // Use previous dir for last point
                             // _v2 already holds previous direction roughly
                        }
                        
                        // Billboarding: Vector to Camera
                        _v3.subVectors(_camPos, _v1);

                        // Cross Product for Perpendicular Vector
                        // _v2 = dir, _v3 = view
                        // _v2.cross(_v3) -> but we need result in temp
                        const px = _v3.y * _v2.z - _v3.z * _v2.y;
                        const py = _v3.z * _v2.x - _v3.x * _v2.z;
                        const pz = _v3.x * _v2.y - _v3.y * _v2.x;
                        
                        // Normalize and Scale
                        const len = Math.sqrt(px*px + py*py + pz*pz);
                        if (len > 0.0001) {
                            const s = currentWidth / len;
                            const offX = px * s;
                            const offY = py * s;
                            const offZ = pz * s;

                            const idx = k * 6;
                            // Vertex Left
                            posArr[idx]   = _v1.x + offX;
                            posArr[idx+1] = _v1.y + offY;
                            posArr[idx+2] = _v1.z + offZ;
                            // Vertex Right
                            posArr[idx+3] = _v1.x - offX;
                            posArr[idx+4] = _v1.y - offY;
                            posArr[idx+5] = _v1.z - offZ;
                        }
                    }
                    posAttr.needsUpdate = true;
                }

                this.updateParticles(dt);
            }

            garbageCollect(activeBodies) {
                const activeIds = new Set(activeBodies.map(b => b.id));
                for (const [id, mesh] of this.meshMap) {
                    if (!activeIds.has(id)) {
                        this.scene.remove(mesh);
                        mesh.geometry.dispose();
                        mesh.material.dispose();
                        this.meshMap.delete(id);

                        const trail = this.trailMap.get(id);
                        if (trail) {
                            this.scene.remove(trail.mesh);
                            trail.mesh.geometry.dispose();
                            trail.mesh.material.dispose();
                            this.trailMap.delete(id);
                        }
                    }
                }
            }

            triggerFlash(pos, energy) {
                const light = new THREE.PointLight(0xffaa00, 1, 50);
                light.position.copy(pos);
                light.intensity = Math.min(energy * 0.1, 10);
                this.scene.add(light);
                
                const fade = () => {
                    light.intensity *= 0.8;
                    if (light.intensity < 0.1) {
                        this.scene.remove(light);
                        light.dispose();
                    } else {
                        requestAnimationFrame(fade);
                    }
                };
                fade();
            }

            spawnExplosion(pos, temp) {
                const count = 10; // Reduced for performance
                for(let i=0; i<count; i++) {
                    if (this.particles.length >= this.maxParticles) this.particles.shift();
                    this.particles.push({
                        x: pos.x, y: pos.y, z: pos.z,
                        vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, vz: (Math.random()-0.5)*8,
                        life: 1.0,
                        decay: 0.02 + Math.random() * 0.03
                    });
                }
            }

            spawnTrail(body) {
                if (this.particles.length >= this.maxParticles) this.particles.shift();
                
                const r = body.radius;
                this.particles.push({
                    x: body.pos.x + (Math.random()-0.5)*r,
                    y: body.pos.y + (Math.random()-0.5)*r,
                    z: body.pos.z + (Math.random()-0.5)*r,
                    vx: body.vel.x * 0.1,
                    vy: body.vel.y * 0.1,
                    vz: body.vel.z * 0.1,
                    life: 0.8 + Math.random() * 0.4,
                    decay: 0.03
                });
            }

            updateParticles(dt) {
                let pCount = 0;
                const positions = this.particleSystem.geometry.attributes.position.array;

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life -= p.decay;
                    
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.z += p.vz * dt;
                    
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                        continue;
                    }

                    positions[pCount*3] = p.x;
                    positions[pCount*3+1] = p.y;
                    positions[pCount*3+2] = p.z;
                    pCount++;
                }
                
                this.particleSystem.geometry.setDrawRange(0, pCount);
                this.particleSystem.geometry.attributes.position.needsUpdate = true;
            }
        }

        // ==========================================
        // 4. MAIN INIT & LOOP
        // ==========================================

        const scene = new THREE.Scene();
        // Stars
        {
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<2000; i++) {
                starPos.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({color: 0x555555, size: 0.7});
            scene.add(new THREE.Points(starGeo, starMat));
        }

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 80, 150);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.mouseButtons = {
            LEFT: null,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.ROTATE
        };

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const physics = new PhysicsSystem();
        const visuals = new VisualSystem(scene, camera);

        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.5);
        sunLight.position.set(50, 50, 50);
        scene.add(sunLight);

        function resetScenario(type) {
            physics.bodies = [];
            visuals.garbageCollect([]); 
            
            if (type === 'galaxy') {
                physics.addBody(new Body(500, new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0), 'metal', 1000));
                for(let i=0; i<150; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 30 + Math.random() * 60;
                    const velocity = Math.sqrt(CONFIG.G * 500 / dist);
                    const pos = new THREE.Vector3(Math.cos(angle)*dist, (Math.random()-0.5)*2, Math.sin(angle)*dist);
                    const vel = new THREE.Vector3(-Math.sin(angle)*velocity, 0, Math.cos(angle)*velocity);
                    physics.addBody(new Body(Math.random() * 2 + 0.5, pos, vel, 'rock'));
                }
            } else if (type === 'collision') {
                physics.addBody(new Body(100, new THREE.Vector3(-40, 0, 0), new THREE.Vector3(1, 0, 0), 'rock'));
                physics.addBody(new Body(100, new THREE.Vector3(40, 0, 10), new THREE.Vector3(-1, 0, 0), 'ice')); 
            }
        }
        
        resetScenario('galaxy');

        // Input Handling
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let dragStart = null;
        let dragLine = null;

        window.addEventListener('mousedown', (e) => {
            if (e.button === 0 && !e.target.closest('.lil-gui')) { 
                controls.enabled = false; 

                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const target = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, target);
                
                if (target) {
                    dragStart = target;
                    const points = [dragStart, dragStart];
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    dragLine = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                    scene.add(dragLine);
                }
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (dragStart) {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const target = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, target);
                
                if (target && dragLine) {
                    const positions = dragLine.geometry.attributes.position.array;
                    positions[3] = target.x;
                    positions[4] = target.y;
                    positions[5] = target.z;
                    dragLine.geometry.attributes.position.needsUpdate = true;
                }
            }
        });

        window.addEventListener('mouseup', (e) => {
            controls.enabled = true; 

            if (dragStart) {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const target = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, target);
                
                if (target) {
                    const vel = target.clone().sub(dragStart).multiplyScalar(-0.5); 
                    physics.addBody(new Body(10, dragStart, vel, 'rock'));
                }
                
                if (dragLine) {
                    scene.remove(dragLine);
                    dragLine = null;
                }
                dragStart = null;
            }
        });

        // GUI
        const gui = new GUI();
        const folderPhys = gui.addFolder('Physics');
        folderPhys.add(CONFIG, 'G', 0.1, 5.0).name('Gravity G');
        folderPhys.add(CONFIG, 'dt', 0.001, 0.05).name('Time Step');
        folderPhys.add(CONFIG, 'fractureThreshold', 1, 50).name('Break Strength');
        
        const folderVis = gui.addFolder('Visuals');
        folderVis.add(bloomPass, 'strength', 0, 3).name('Bloom Str');
        folderVis.add(bloomPass, 'threshold', 0, 1).name('Bloom Thresh');
        
        const folderScen = gui.addFolder('Scenarios');
        const scenarios = {
            'Galaxy Disk': () => resetScenario('galaxy'),
            'Head-on Collision': () => resetScenario('collision')
        };
        folderScen.add(scenarios, 'Galaxy Disk');
        folderScen.add(scenarios, 'Head-on Collision');

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            for(let i=0; i<CONFIG.subSteps; i++) {
                physics.integrate(CONFIG.dt / CONFIG.subSteps);
            }
            
            visuals.update(physics.bodies, CONFIG.dt);
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
