<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Realistic N-Body Sim</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050508; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        #instructions {
            position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.6);
            pointer-events: none; user-select: none; text-shadow: 1px 1px 2px black;
        }
        b { color: #ff9d00; }
        h2 { margin-bottom: 5px; color: #fff; }
        .mode-indicator {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            font-size: 1.2rem; color: #fff; background: rgba(0,0,0,0.5); padding: 10px 20px;
            border-radius: 20px; border: 1px solid #444; pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="mode-ui" class="mode-indicator">Mode: View</div>
    <div id="instructions">
        <h2>Realistic N-Body Fusion</h2>
        <p>Right Click: <b>Pan Camera</b></p>
        <p>Left Click (Add Mode): <b>Spawn Body</b></p>
        <p>Left Click (View Mode): <b>Rotate Camera</b></p>
        <p>Wheel: <b>Zoom</b></p>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'three/addons/libs/lil-gui.module.min.js';

        // ==========================================
        // 1. CONFIGURATION
        // ==========================================
        const CONFIG = {
            G: 0.5,                
            softening: 0.5,        
            dt: 0.016,             
            subSteps: 2,           
            maxBodies: 300,        
            trailLength: 80,      
            
            interactionMode: 'view', 
            spawnMass: 20,           
            
            fractureThreshold: 25,   
            minFragmentMass: 0.2,  
            mergeTime: 0.5,          
            
            heatDecay: 0.998,      
            heatToGlow: 3.0,       
            
            materials: {
                rock: { density: 1.0, color1: new THREE.Color(0.4, 0.3, 0.2), color2: new THREE.Color(0.1, 0.1, 0.1) },
                metal: { density: 3.0, color1: new THREE.Color(0.6, 0.6, 0.7), color2: new THREE.Color(0.3, 0.3, 0.4) },
                ice: { density: 0.5, color1: new THREE.Color(0.8, 0.9, 1.0), color2: new THREE.Color(0.1, 0.3, 0.6) }
            }
        };

        const V3 = (x, y, z) => new THREE.Vector3(x, y, z);

        // ==========================================
        // 2. SHADERS (REALISM)
        // ==========================================
        
        const planetVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vViewPosition;

            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                vec4 mvPosition = viewMatrix * modelMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const planetFragmentShader = `
            uniform vec3 color1;
            uniform vec3 color2;
            uniform float time;
            uniform float temperature;
            uniform float seed;
            uniform vec3 sunPosition;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vViewPosition;

            // Simplex Noise (Simplified)
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute( permute( permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                // Noise generation for surface detail
                float n = snoise(vPosition * 0.5 + vec3(seed));
                float n2 = snoise(vPosition * 2.0 + vec3(seed * 2.0));
                float detail = n * 0.6 + n2 * 0.4;

                // Base Color Mixing
                vec3 finalColor = mix(color2, color1, smoothstep(-0.2, 0.5, detail));

                // Lighting (Directional Sun)
                vec3 lightDir = normalize(sunPosition - vPosition);
                vec3 viewDir = normalize(vViewPosition);
                vec3 normal = normalize(vNormal);
                
                // Add bumpiness to normal
                normal = normalize(normal + vec3(detail * 0.1));

                float diff = max(dot(normal, lightDir), 0.0);
                
                // Atmosphere / Fresnel (Rim Light)
                float fresnel = pow(1.0 - dot(viewDir, normal), 3.0);
                vec3 atmosphere = color1 * fresnel * 0.5;

                // Temperature Glow (Magma)
                float heatIntensity = clamp(temperature / 50.0, 0.0, 1.0);
                // Heat appears in cracks (inverted noise)
                float crack = smoothstep(0.4, 0.6, abs(n2)); 
                vec3 heatColor = vec3(1.0, 0.3, 0.1) * (1.0 - crack) * heatIntensity * 5.0;
                
                // Full body glow if very hot
                vec3 bodyGlow = vec3(1.0, 0.5, 0.2) * max(0.0, temperature - 50.0) * 0.005;

                // Combine
                vec3 ambient = vec3(0.05);
                vec3 lighting = finalColor * (diff + ambient) + atmosphere + heatColor + bodyGlow;

                gl_FragColor = vec4(lighting, 1.0);
            }
        `;

        // ==========================================
        // 3. PHYSICS ENGINE
        // ==========================================
        
        class Body {
            constructor(mass, pos, vel, type = 'rock', temp = 0) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.mass = mass;
                this.invMass = mass > 0 ? 1 / mass : 0;
                
                this.pos = pos.clone();
                this.prevPos = pos.clone(); 
                this.vel = vel.clone();
                this.acc = new THREE.Vector3(0, 0, 0);
                
                this.type = type;
                this.matProps = CONFIG.materials[type];
                this.radius = Math.pow((3 * mass) / (4 * Math.PI * this.matProps.density), 1/3);
                
                this.temperature = temp;
                this.history = [];
            }

            updateThermal() {
                this.temperature *= CONFIG.heatDecay;
                if(this.temperature < 0.1) this.temperature = 0;
            }
        }

        class PhysicsSystem {
            constructor() {
                this.bodies = [];
                this.contactPairs = new Map();
            }

            addBody(body) {
                if (this.bodies.length >= CONFIG.maxBodies) {
                    this.bodies.shift(); 
                }
                this.bodies.push(body);
                return body;
            }

            integrate(dt) {
                const halfDt = 0.5 * dt;

                for (const b of this.bodies) {
                    b.vel.addScaledVector(b.acc, halfDt);
                    b.pos.addScaledVector(b.vel, dt);
                }

                this.computeGravity();
                this.resolveCollisions(dt);

                for (const b of this.bodies) {
                    b.vel.addScaledVector(b.acc, halfDt);
                    b.updateThermal();
                }
            }

            computeGravity() {
                const N = this.bodies.length;
                for (let i = 0; i < N; i++) this.bodies[i].acc.set(0, 0, 0);

                const G = CONFIG.G;
                const epsSq = CONFIG.softening * CONFIG.softening;
                const vec = new THREE.Vector3();

                for (let i = 0; i < N; i++) {
                    for (let j = i + 1; j < N; j++) {
                        const A = this.bodies[i];
                        const B = this.bodies[j];

                        vec.subVectors(B.pos, A.pos);
                        const distSq = vec.lengthSq();
                        
                        const f = G / Math.pow(distSq + epsSq, 1.5);
                        
                        A.acc.x += f * B.mass * vec.x;
                        A.acc.y += f * B.mass * vec.y;
                        A.acc.z += f * B.mass * vec.z;

                        B.acc.x -= f * A.mass * vec.x;
                        B.acc.y -= f * A.mass * vec.y;
                        B.acc.z -= f * A.mass * vec.z;
                    }
                }
            }

            resolveCollisions(dt) {
                const newBodies = [];
                const removedIndices = new Set();
                const N = this.bodies.length;
                const vec = new THREE.Vector3();
                const relVel = new THREE.Vector3();
                const currentFrameContacts = new Set();

                for (let i = 0; i < N; i++) {
                    if (removedIndices.has(i)) continue;
                    for (let j = i + 1; j < N; j++) {
                        if (removedIndices.has(j)) continue;

                        const A = this.bodies[i];
                        const B = this.bodies[j];
                        
                        vec.subVectors(B.pos, A.pos);
                        const distSq = vec.lengthSq();
                        const minDist = A.radius + B.radius;

                        if (distSq < minDist * minDist) {
                            const pairId = [A.id, B.id].sort().join('-');
                            currentFrameContacts.add(pairId);
                            
                            const prevContactTime = this.contactPairs.get(pairId) || 0;
                            const newContactTime = prevContactTime + dt;
                            this.contactPairs.set(pairId, newContactTime);

                            const dist = Math.sqrt(distSq);
                            const normal = vec.clone().normalize();

                            relVel.subVectors(B.vel, A.vel);
                            const velAlongNormal = relVel.dot(normal);

                            if (velAlongNormal < 0) {
                                const restitution = 0.2; 
                                const jImpulse = -(1 + restitution) * velAlongNormal / (A.invMass + B.invMass);
                                const impulse = normal.clone().multiplyScalar(jImpulse);
                                
                                const mu = (A.mass * B.mass) / (A.mass + B.mass);
                                const impactEnergy = 0.5 * mu * velAlongNormal * velAlongNormal;
                                
                                A.temperature += (impactEnergy / A.mass) * 0.2;
                                B.temperature += (impactEnergy / B.mass) * 0.2;

                                const Q = impactEnergy / (A.mass + B.mass);
                                
                                if (newContactTime > CONFIG.mergeTime && Q < CONFIG.fractureThreshold * 2) {
                                    this.mergeBodies(A, B, newBodies);
                                    removedIndices.add(i);
                                    removedIndices.add(j);
                                    this.contactPairs.delete(pairId);
                                    continue;
                                }

                                const isFracture = Q > CONFIG.fractureThreshold;

                                const correction = normal.clone().multiplyScalar((minDist - dist) / (A.invMass + B.invMass) * 0.8);
                                A.pos.sub(correction.clone().multiplyScalar(A.invMass));
                                B.pos.add(correction.clone().multiplyScalar(B.invMass));

                                if (isFracture && (A.mass > CONFIG.minFragmentMass || B.mass > CONFIG.minFragmentMass)) {
                                    this.fractureBodies(A, B, impactEnergy, newBodies);
                                    removedIndices.add(i);
                                    removedIndices.add(j);
                                    visuals.triggerFlash(A.pos.clone().add(B.pos).multiplyScalar(0.5), impactEnergy);
                                    this.contactPairs.delete(pairId);
                                } else {
                                    A.vel.sub(impulse.clone().multiplyScalar(A.invMass));
                                    B.vel.add(impulse.clone().multiplyScalar(B.invMass));
                                    
                                    const tangent = relVel.clone().sub(normal.clone().multiplyScalar(velAlongNormal)).normalize();
                                    const jt = -relVel.dot(tangent) * 0.5 / (A.invMass + B.invMass);
                                    const tangentImpulse = tangent.multiplyScalar(jt);
                                    
                                    A.vel.sub(tangentImpulse.clone().multiplyScalar(A.invMass));
                                    B.vel.add(tangentImpulse.clone().multiplyScalar(B.invMass));
                                }
                            }
                        }
                    }
                }

                for (const key of this.contactPairs.keys()) {
                    if (!currentFrameContacts.has(key)) {
                        this.contactPairs.delete(key);
                    }
                }

                if (removedIndices.size > 0) {
                    this.bodies = this.bodies.filter((_, idx) => !removedIndices.has(idx));
                    visuals.garbageCollect(this.bodies);
                }
                
                for (const nb of newBodies) {
                    this.addBody(nb);
                }
            }

            mergeBodies(A, B, newBodiesList) {
                const newMass = A.mass + B.mass;
                const momentumA = A.vel.clone().multiplyScalar(A.mass);
                const momentumB = B.vel.clone().multiplyScalar(B.mass);
                const newVel = momentumA.add(momentumB).multiplyScalar(1 / newMass);
                
                const posA = A.pos.clone().multiplyScalar(A.mass);
                const posB = B.pos.clone().multiplyScalar(B.mass);
                const newPos = posA.add(posB).multiplyScalar(1 / newMass);

                const newTemp = (A.temperature * A.mass + B.temperature * B.mass) / newMass;
                const type = A.mass > B.mass ? A.type : B.type;

                const mergedBody = new Body(newMass, newPos, newVel, type, newTemp);
                newBodiesList.push(mergedBody);
                
                visuals.triggerFlash(newPos, newMass * 0.5);
            }

            fractureBodies(A, B, energy, newBodiesList) {
                const totalMass = A.mass + B.mass;
                const centerOfMass = A.pos.clone().multiplyScalar(A.mass).add(B.pos.clone().multiplyScalar(B.mass)).multiplyScalar(1/totalMass);
                const totalMomentum = A.vel.clone().multiplyScalar(A.mass).add(B.vel.clone().multiplyScalar(B.mass));
                const baseVel = totalMomentum.multiplyScalar(1/totalMass);

                const severity = Math.min(energy / CONFIG.fractureThreshold, 5.0); 
                const numFragments = Math.floor(3 + Math.random() * 3 * severity);
                let remainingMass = totalMass;
                
                for (let k = 0; k < numFragments; k++) {
                    if (remainingMass < CONFIG.minFragmentMass) break;
                    
                    let fragMass = remainingMass * (0.3 + Math.random() * 0.4);
                    if (k === numFragments - 1) fragMass = remainingMass;
                    
                    if (fragMass < CONFIG.minFragmentMass) continue;
                    remainingMass -= fragMass;

                    const scatterDir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                    const offset = scatterDir.clone().multiplyScalar((A.radius + B.radius) * 0.5 * Math.random());
                    const fragPos = centerOfMass.clone().add(offset);
                    const ejectSpeed = Math.sqrt(energy / totalMass) * (0.5 + Math.random());
                    const fragVel = baseVel.clone().add(scatterDir.multiplyScalar(ejectSpeed));
                    const fragTemp = Math.max(A.temperature, B.temperature) + (energy / totalMass) * 0.1;

                    const type = A.mass > B.mass ? A.type : B.type;
                    const frag = new Body(fragMass, fragPos, fragVel, type, fragTemp);
                    
                    newBodiesList.push(frag);
                    visuals.spawnExplosion(fragPos, fragTemp);
                }
            }
        }

        // ==========================================
        // 4. VISUALS & RENDERING
        // ==========================================

        class VisualSystem {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.meshMap = new Map();
                this.trailMap = new Map(); 
                
                // Use a higher detail geometry for realistic planets
                this.geo = new THREE.IcosahedronGeometry(1, 4);
                
                // Particle System
                this.particles = [];
                const pGeo = new THREE.BufferGeometry();
                const pMat = new THREE.PointsMaterial({ 
                    color: 0xffaa44,
                    size: 1.2, 
                    blending: THREE.AdditiveBlending, 
                    transparent: true, 
                    opacity: 0.8,
                    depthWrite: false 
                });
                this.particleSystem = new THREE.Points(pGeo, pMat);
                this.particleSystem.frustumCulled = false;
                scene.add(this.particleSystem);
                
                this.maxParticles = 5000;
                this.pPositions = new Float32Array(this.maxParticles * 3);
                pGeo.setAttribute('position', new THREE.BufferAttribute(this.pPositions, 3));

                this.vecToCam = new THREE.Vector3();
                this.vecDir = new THREE.Vector3();
                this.vecPerp = new THREE.Vector3();
            }

            createPlanetMaterial(type) {
                const props = CONFIG.materials[type];
                return new THREE.ShaderMaterial({
                    uniforms: {
                        color1: { value: props.color1 },
                        color2: { value: props.color2 },
                        time: { value: 0 },
                        temperature: { value: 0 },
                        seed: { value: Math.random() * 100 },
                        sunPosition: { value: new THREE.Vector3(50, 50, 50) }
                    },
                    vertexShader: planetVertexShader,
                    fragmentShader: planetFragmentShader
                });
            }

            update(bodies, dt) {
                const currentIds = new Set();
                const time = performance.now() * 0.001;
                
                bodies.forEach(body => {
                    currentIds.add(body.id);
                    let mesh = this.meshMap.get(body.id);

                    if (!mesh) {
                        const mat = this.createPlanetMaterial(body.type);
                        mesh = new THREE.Mesh(this.geo, mat);
                        this.scene.add(mesh);
                        this.meshMap.set(body.id, mesh);

                        // Ribbon Trail
                        const trailLen = CONFIG.trailLength;
                        const trailGeo = new THREE.BufferGeometry();
                        const positions = new Float32Array(trailLen * 2 * 3); 
                        const indices = [];
                        for (let i = 0; i < trailLen - 1; i++) {
                            const v = i * 2;
                            indices.push(v, v+1, v+2);
                            indices.push(v+1, v+3, v+2);
                        }
                        
                        trailGeo.setIndex(indices);
                        trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const trailMat = new THREE.MeshBasicMaterial({ 
                            color: body.matProps.color1, 
                            transparent: true, 
                            opacity: 0.3,
                            blending: THREE.AdditiveBlending,
                            side: THREE.DoubleSide,
                            depthWrite: false
                        });
                        
                        const trailMesh = new THREE.Mesh(trailGeo, trailMat);
                        trailMesh.frustumCulled = false;
                        this.scene.add(trailMesh);
                        
                        for(let k=0; k<trailLen; k++) body.history.push(body.pos.clone());
                        this.trailMap.set(body.id, { mesh: trailMesh, positions: positions });
                    }

                    mesh.position.copy(body.pos);
                    mesh.scale.setScalar(body.radius);
                    
                    // Rotate planet
                    mesh.rotation.y += dt * 0.2;

                    // Update Material Uniforms
                    mesh.material.uniforms.time.value = time;
                    mesh.material.uniforms.temperature.value = body.temperature;

                    if (body.temperature > 50) {
                        const spawnChance = Math.min(0.1 + (body.temperature - 50) * 0.002, 1.0);
                        if (Math.random() < spawnChance) {
                            this.spawnTrail(body);
                        }
                    }

                    // Update Ribbon
                    const trailData = this.trailMap.get(body.id);
                    body.history.unshift(body.pos.clone());
                    if (body.history.length > CONFIG.trailLength) body.history.pop();

                    const posAttr = trailData.mesh.geometry.attributes.position;
                    const posArr = posAttr.array;
                    
                    for (let i = 0; i < body.history.length; i++) {
                        const p = body.history[i];
                        const widthRatio = 1.0 - (i / (CONFIG.trailLength - 1));
                        const currentWidth = body.radius * 0.8 * Math.max(0, widthRatio);

                        this.vecToCam.subVectors(this.camera.position, p);
                        
                        if (i < body.history.length - 1) {
                            this.vecDir.subVectors(body.history[i], body.history[i+1]);
                        } else {
                            this.vecDir.subVectors(body.history[i-1], body.history[i]);
                        }
                        
                        this.vecPerp.crossVectors(this.vecToCam, this.vecDir).normalize().multiplyScalar(currentWidth);

                        posArr[i*6 + 0] = p.x + this.vecPerp.x;
                        posArr[i*6 + 1] = p.y + this.vecPerp.y;
                        posArr[i*6 + 2] = p.z + this.vecPerp.z;

                        posArr[i*6 + 3] = p.x - this.vecPerp.x;
                        posArr[i*6 + 4] = p.y - this.vecPerp.y;
                        posArr[i*6 + 5] = p.z - this.vecPerp.z;
                    }
                    posAttr.needsUpdate = true;
                });

                this.updateParticles(dt);
            }

            garbageCollect(activeBodies) {
                const activeIds = new Set(activeBodies.map(b => b.id));
                for (const [id, mesh] of this.meshMap) {
                    if (!activeIds.has(id)) {
                        this.scene.remove(mesh);
                        mesh.geometry.dispose();
                        mesh.material.dispose();
                        this.meshMap.delete(id);

                        const trail = this.trailMap.get(id);
                        if (trail) {
                            this.scene.remove(trail.mesh);
                            trail.mesh.geometry.dispose();
                            trail.mesh.material.dispose();
                            this.trailMap.delete(id);
                        }
                    }
                }
            }

            triggerFlash(pos, energy) {
                const light = new THREE.PointLight(0xffaa00, 1, 60);
                light.position.copy(pos);
                light.intensity = Math.min(energy * 0.2, 15);
                this.scene.add(light);
                
                const fade = () => {
                    light.intensity *= 0.85;
                    if (light.intensity < 0.1) {
                        this.scene.remove(light);
                        light.dispose();
                    } else {
                        requestAnimationFrame(fade);
                    }
                };
                fade();
            }

            spawnExplosion(pos, temp) {
                const count = 15;
                for(let i=0; i<count; i++) {
                    if (this.particles.length >= this.maxParticles) this.particles.shift();
                    this.particles.push({
                        pos: pos.clone(),
                        vel: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(Math.random() * 8),
                        life: 1.0,
                        decay: 0.01 + Math.random() * 0.03
                    });
                }
            }

            spawnTrail(body) {
                if (this.particles.length >= this.maxParticles) this.particles.shift();
                const offset = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(body.radius);
                const spawnPos = body.pos.clone().add(offset);
                const trailVel = body.vel.clone().multiplyScalar(0.1).add(
                    new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(0.5)
                );
                this.particles.push({
                    pos: spawnPos,
                    vel: trailVel,
                    life: 0.8 + Math.random() * 0.4,
                    decay: 0.03
                });
            }

            updateParticles(dt) {
                let pCount = 0;
                const positions = this.particleSystem.geometry.attributes.position.array;

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life -= p.decay;
                    p.pos.addScaledVector(p.vel, dt);
                    
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                        continue;
                    }

                    positions[pCount*3] = p.pos.x;
                    positions[pCount*3+1] = p.pos.y;
                    positions[pCount*3+2] = p.pos.z;
                    pCount++;
                }
                
                this.particleSystem.geometry.setDrawRange(0, pCount);
                this.particleSystem.geometry.attributes.position.needsUpdate = true;
            }
        }

        // ==========================================
        // 5. MAIN INIT & LOOP
        // ==========================================

        const scene = new THREE.Scene();
        // Stars
        {
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<3000; i++) {
                starPos.push((Math.random()-0.5)*1500, (Math.random()-0.5)*1500, (Math.random()-0.5)*1500);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({color: 0x888888, size: 0.8, transparent: true, opacity: 0.8});
            scene.add(new THREE.Points(starGeo, starMat));
        }

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.set(0, 80, 150);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN
        };

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.3; 
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const physics = new PhysicsSystem();
        const visuals = new VisualSystem(scene, camera);

        // Sun Light (Visual representation matching shader light dir)
        const sunPos = new THREE.Vector3(50, 50, 50);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.copy(sunPos);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x111111));

        function resetScenario(type) {
            physics.bodies = [];
            physics.contactPairs.clear();
            visuals.garbageCollect([]); 
            
            if (type === 'galaxy') {
                physics.addBody(new Body(500, V3(0,0,0), V3(0,0,0), 'metal', 1000));
                for(let i=0; i<150; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 30 + Math.random() * 60;
                    const velocity = Math.sqrt(CONFIG.G * 500 / dist);
                    const pos = V3(Math.cos(angle)*dist, (Math.random()-0.5)*2, Math.sin(angle)*dist);
                    const vel = V3(-Math.sin(angle)*velocity, 0, Math.cos(angle)*velocity);
                    const type = Math.random() > 0.8 ? 'ice' : 'rock';
                    physics.addBody(new Body(Math.random() * 2 + 0.5, pos, vel, type));
                }
            } else if (type === 'collision') {
                physics.addBody(new Body(100, V3(-40, 0, 0), V3(1, 0, 0), 'rock'));
                physics.addBody(new Body(100, V3(40, 0, 10), V3(-1, 0, 0), 'ice')); 
            }
        }
        
        resetScenario('galaxy');

        // Input Handling
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let dragStart = null;
        let dragLine = null;
        const uiMode = document.getElementById('mode-ui');

        function updateModeUI() {
            uiMode.innerText = `Mode: ${CONFIG.interactionMode === 'add' ? 'ADD (Drag to Spawn)' : 'VIEW (Rotate)'}`;
            uiMode.style.color = CONFIG.interactionMode === 'add' ? '#ff9d00' : '#ffffff';
        }

        window.addEventListener('mousedown', (e) => {
            if (e.button === 0 && !e.target.closest('.lil-gui')) { 
                if (CONFIG.interactionMode === 'add') {
                    controls.enabled = false;
                    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                    const target = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, target);
                    
                    if (target) {
                        dragStart = target;
                        const points = [dragStart, dragStart];
                        const geo = new THREE.BufferGeometry().setFromPoints(points);
                        dragLine = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                        scene.add(dragLine);
                    }
                }
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (dragStart && CONFIG.interactionMode === 'add') {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const target = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, target);
                
                if (target && dragLine) {
                    const positions = dragLine.geometry.attributes.position.array;
                    positions[3] = target.x;
                    positions[4] = target.y;
                    positions[5] = target.z;
                    dragLine.geometry.attributes.position.needsUpdate = true;
                }
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (CONFIG.interactionMode === 'add') {
                controls.enabled = true;
                if (dragStart) {
                    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                    const target = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, target);
                    
                    if (target) {
                        const vel = target.clone().sub(dragStart).multiplyScalar(-0.5); 
                        physics.addBody(new Body(CONFIG.spawnMass, dragStart, vel, 'rock'));
                    }
                    if (dragLine) {
                        scene.remove(dragLine);
                        dragLine = null;
                    }
                    dragStart = null;
                }
            }
        });

        // GUI
        const gui = new GUI();
        
        const folderInteract = gui.addFolder('Interaction');
        folderInteract.add(CONFIG, 'interactionMode', ['view', 'add']).name('Mode').onChange(updateModeUI);
        folderInteract.add(CONFIG, 'spawnMass', 1, 5000).name('Spawn Mass');

        const folderPhys = gui.addFolder('Physics');
        folderPhys.add(CONFIG, 'G', 0.1, 5.0).name('Gravity G');
        folderPhys.add(CONFIG, 'dt', 0.001, 0.05).name('Time Step');
        folderPhys.add(CONFIG, 'fractureThreshold', 1, 100).name('Break Strength');
        folderPhys.add(CONFIG, 'mergeTime', 0.1, 3.0).name('Merge Time (s)');
        
        const folderVis = gui.addFolder('Visuals');
        folderVis.add(bloomPass, 'strength', 0, 3).name('Bloom Str');
        folderVis.add(bloomPass, 'threshold', 0, 1).name('Bloom Thresh');
        
        const folderScen = gui.addFolder('Scenarios');
        const scenarios = {
            'Galaxy Disk': () => resetScenario('galaxy'),
            'Head-on Collision': () => resetScenario('collision')
        };
        folderScen.add(scenarios, 'Galaxy Disk');
        folderScen.add(scenarios, 'Head-on Collision');

        updateModeUI();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            for(let i=0; i<CONFIG.subSteps; i++) {
                physics.integrate(CONFIG.dt / CONFIG.subSteps);
            }
            
            visuals.update(physics.bodies, CONFIG.dt);
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.setSize(new THREE.Vector2(window.innerWidth, window.innerHeight));
        });

        animate();
    </script>
</body>
</html>
